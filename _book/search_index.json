[["index.html", "Computational Phylogenetics: A Hands-on Tutorial Welcome", " Computational Phylogenetics: A Hands-on Tutorial Mingyu Yuan 2022-05-13 Welcome üëã Hi! This tutorial is largely inspired by Prof.¬†Andrew Garrett‚Äôs class (LING230 Advanced Historical Linguistics, Spring 2022) and Edwin Ko‚Äôs past and current work on computational phylogenetics. I am deeply grateful to both of them. All errors are my own. The purposes of this tutorial are three-fold. First, to briefly summarize the past and present of computational phylogenetics, providing an overview of computatioanl methods applied in this line of research. Second, to introduce Bayesian phylogenetics and relevant details, including trait selection, data format and coding scheme, and existing software and packages. Lastly, to give a step-by-step tutorial of implementing Bayesian-MCMC method in command lines with Beastling. Ko (2021)‚Äôs analysis of the phylogeny of Siouan is reproduced in Section 3. This tutorial does require basic understandings of historical linguistic terms, though wiki links or relevant introductory materials are provided whenever a term is mentioned. This tutorial does not assume or require any programming background though. The .R file used to preprocess data is available in the project repository. Command line basics are introduced in Section 3. This tutorial is written in Markdown and compiled by Bookdown. It is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. You can find the full source of this project at https://github.com/zimine/chl. Notes: I use traits, features, and characters interchangeably throughout the tutorial. The first two sections are highly-condensed summaries of computational phylogenetics. See Nichols and Warnow (2008), Dunn (2015), Bowern (2018), and J√§ger (2019) for general introductions to computational phylogenetics; also see Hoffmann et al. (2021) for a tutorial of implementing Bayesian phylogenetcis in BEAST. References "],["overview.html", "1 Overview 1.1 The first wave 1.2 Bayesian phylogenetics 1.3 Other appraoches", " 1 Overview 1.1 The first wave Using computational methods to infer linguistic phylogenies has been flourishing in the recent decades. To put it more accurately, the term computational here refers specifically to the Bayesian approach to linguistic phylogenetic estimation. The first wave of this line of research‚Äîlexicostatistics and glottochronology‚Äîhas been extensively criticized. Lexicostatistics estimates linguistic similarity based on proportions of shared cognates in a set of core vocabulary, for instance, a Swadesh 100 list (Swadesh 1955) or 200 list (Swadesh 1952). Built upon lexicostatistics, glottochronology dates lineage-splitting between language pairs. Arguments against these early methods are well-described in the literature (Bowern 2018; Dunn 2015; Goldstein 2020)1. To briefly summarize, they are flawed in terms of data and assumptions. On one hand, this line of research is entirely based on cognates, which simply captures lexical similarity or linguistic distance, instead of linguistic phylogenies. A cognate list as such does not inform us of the reasons why cognates exist in the first place; moreover, it does not distinguish shared retention from shared innovation, despite the fact that the latter is more informative when constructing a phylogenetic tree2. It is important to keep in mind that shared retentions are of practically no value for subgrouping. A shared retention is merely something that different daughter languages inherit unchanged from the proto-language regardless of whether the daughters belong to the same subgroup or not [‚Ä¶] Shared retentions just do not reveal which languages share a period of common history after the break-up of the proto-language (Campbell 2013, 33‚Äì35). On the other hand, glottochronology, according to its formula3, assumes that language change follows a single, constant rate, instead of allowing variation in the rate of change, which often occurs in language families like Indo-European. 1.2 Bayesian phylogenetics Unlike the above approaches, Bayesian phylogenetics is more of a domain general method (see Huelsenbeck et al. 2001 for a general introduction to this method). Its first debut was in evolutionary biology and was later applied in linguistics; it is sometimes termed Bayesian Phylolinguistics, see Greenhill, Heggarty, and Gray (2020) for details. By definition, Bayesian phylogenetics has its roots in Bayes Theorom, which estimates the posterior probability of a phylogenetic tree given the prior probability of the tree and the likelihood to produce such a tree in light of the data. \\[\\begin{equation} \\Pr(Tree|Data)=\\frac{\\Pr(Data|Tree) \\times \\Pr(Tree)}{\\Pr(Data)} \\end{equation}\\] The prior refers to a set of parameters that we assume from the data, such as tree structure, rate of change, evolution model, branch length, and etc. The posterior refers to how likely phylogenies inferred from the data are correct. The posterior probability involves computation-intensive calculation, which cannot be easily done analytically (Huelsenbeck et al. 2001); Markov Chain Monte Carlo (MCMC) is often coupled with Bayesian phylogenetics to speed up the estimation of posterior distribution. MCMC starts with a random tree or step with an often random set of model parameters to calculate the likelihood of a phylogenetic tree (Greenhill, Heggarty, and Gray 2020). The likelihood score is constantly evaluated and updated as the algorithm moves on to the next state. If the likelihood score of the current step is higher, then relevant parameters are cached; if not, then they are discarded (Greenhill, Heggarty, and Gray 2020). The purpose of this searching process, which takes up most of the run time, is to obtain a posterior distribution that best approximates the data and left unchanged when preceding to the next step (Greenhill, Heggarty, and Gray 2020). The end products of Bayesian phylogenetic inference is a set of possible trees and posterior probabilities of clades. A consensus tree is a collection of representative trees, which often provides a general picture of subgrouping. There exists a number of software and/or packages to implement Bayesian phylogenetics, such as MrBayes (Ronquist and Huelsenbeck 2003), RevBayes (H√∂hna et al. 2016), and BEAST 2 (Bouckaert et al. 2014). These tools are largely domain general or specific to evolutionary biology; see their homepages for tutorials and workshops. BEASTling (Maurits et al. 2017), which is introduced in this tutorial, is primarily linguist-oriented. 1.3 Other appraoches Leveraging computation power, Bayesian-MCMC methods are able to derive countless phylogenetic trees. Distance-based methods such as UPGMA4 or in generally accepted term clustering analysis, which are often implemented with R (R Core Team 2021), do not generate thousands of trees given prior probabilities. These methods estimate lineage-splitting based on similarity (i.e.¬†shared traits) between languages. The major issue of such methods lies in that it assumes an equal rate of change among languages, which could potentially be wide of the mark for datasets like Indo-European languages (Goldstein 2020). Distance-based methods are not covered in the tutorial; see Johnson (2011, 182‚Äì208) and Goldstein (2020) for detailed introductions and tutorials of implementing these methods with R (R Core Team 2021). References "],["bascis.html", "2 Bascis 2.1 Trait selection 2.2 Data curation 2.3 Databases and resources", " 2 Bascis 2.1 Trait selection 2.1.1 Lexical traits Similar to the comparative method, Bayesian phylogenetics rely on lexical, phonological, morphological, syntactic, and typological data to infer linguistic phylogenies. The comparative method often draws inferences from other data types (e.g.¬†sound correspondences or morphological paradigms) as they are more representative, conclusive, and trusted. Bayesian phylogenetics mostly focuses on lexical and/or typological traits. Morphological and phonological traits are often interdependent, thus unsuited for statistical analysis (Chang et al. 2015). The lexicon or vocabulary would often be the first choice when it comes to Bayesian phylogenetics, partly due to data availability issue. There are three major concerns regarding using lexical traits to infer linguistic phylogeneies. First, the term lexical traits is in fact not accurate, neither does cognate set. In a typical cognate set, we would see each slot occupied by lexeme in each language. However, what fed into phylogenetic analysis is not lexeme but cognate relationship with cognacy coded as 0s and 1s in the data. The binary or multi-state matrix might not be fully representative of a cognate set. Second, this kind of dataset is often based on root-meaning traits, which require shared meanings; the forms or roots can vary. For instance, English feather and Latin penna share the trait of PIE *pet (to fly) but are not cognates as they do not descend from the same word (feather &gt; *pet-tra vs.¬†penna &gt; *pet-na) (Chang et al. 2015). Cognates, on the other hand, do not necessarily require shared meanings but do require descendance from the common proto-form. For example, English rain and German Regen are considered cognates because both descend from the proto-Germanic *regna (Greenhill, Heggarty, and Gray 2020). Motivations underlying cognate traits and root-meaning traits are different. Cognate traits are used to investigate descendance from common ancestral forms, during which semantic shifts may occur, giving rise to cogante words with different meanings. On the other hand, root-meaning traits arise in languages due to multiple reasons. Semantic shift may cause words to have the same meanings but different forms, so does derivational shift‚Äîcertain roots are well suited to innovate derivatives; and this process may occur independently within language (i.e.¬†homoplasy5). Lastly, selecting cognates based on meanings does not mean any arbitrary semantic units present in the language. Meanings here largely refer to the core vocabulary (i.e.¬†Swadesh list), which is assumed to be universal and consistent across languages and resistant to change. That being said, it is not necessarily true that the core vocabulary is borrowing-free (Greenhill, Heggarty, and Gray 2020). To sum up, lexical traits may be subject to the limitations of core vocabulary and its conversion to binary data. More often is the case that cognate traits and root-meaning traits are mixed in the dataset. Assigning cognacy properly thus becomes the first and biggest question of using lexical traits. 2.1.2 Typological traits Typological traits do share the same drawback of being interdependent; however, they could provide us with language-specific information as well as cross-linguistic generalizations. Typological traits can be loosely defined as any features relevant to the language‚Äôs internal structure, for instance, word order and morphosyntactic alignment. Sometimes linguists also extend beyond conventionally defined typological features and include lexico-semantic information. Unlike vocabulary, which is susceptible to borrowing, typological features are believed to be resistant to borrowing. Typological characters are by definition homoplastic (Nichols and Warnow 2008). They are derived directly from the grammar. The same typological character (e.g.¬†glottalized consonants and tone system) is more likely to evolve independently in each language (Nichols and Warnow 2008)6. 2.2 Data curation 2.2.1 Coding scheme Whatever linguistic traits are selected, they are translated to numbers before being fed into phylogenetic analysis. The following table shows the coding of lexical traits (Coastal Sepik)7. For instance, if meaning one is present in the language, then it will be assigned a number; cognacy is indicated by the same numbers. Sepa, Manam, and Kairiru are coded 1 for this trait, then they would not be assigned to a second number. Sepa Manam Kairiru Sera Gloss Coding teka teke tai pontenen ‚Äòone‚Äô 1, 1, 1, 2 lua rua wulu elti≈ã ‚Äòtwo‚Äô 3, 3, 4, 5 toli toli tuol elti≈ã pal ‚Äòthree‚Äô 6, 6, 6, 7 wati wati viat elti≈ã elti≈ã ‚Äòfour‚Äô 8, 8, 8, 9 When it comes to phonological, morphological, and typological features, traits are often translated to binary codes, though multi-state codes are also used. The following example is selected from Goldstein (2020)‚Äôs analysis of Indo-Hittite phylogeny. Features by convention are abbreviated or coded, with detailed descriptions of each feature kept in a separate file. For instance, P4 here refers to lenition of stops after long vowels and unstressed vowels (only) (Goldstein 2020). For each trait, 0 means absence, 1 presence, and ? uncertain or missing data (the data could be either 0 or 1 in this case). Trait Hittite Armenian Greek Albanian Tocharian B ‚Ä¶ P1-01 ? 1 1 1 1 ‚Ä¶ P1-02 0 0 0 0 0 ‚Ä¶ P2 0 0 0 0 0 ‚Ä¶ P3 0 0 0 0 0 ‚Ä¶ P4 0 1 1 1 1 ‚Ä¶ 2.2.2 Data format When linguists compile the dataset, it is fine to have multiple values per cell (table 1) or keep a (horizontally) long spreadsheet (table 2). However, data formats presented above are not ideal for statistical analysis or replication. In recent years, a suite of methods and tools become available, to help linguist curate and explore data following the state-of-the-art guidelines. LingPy is a set of Python modules for a wide range of quantitative analyses in historical linguistics, including phonetic alignment, automatic cognate detection, and other toolkit to curate lexical data (List and Forkel 2016). Cross-Linguistic Data Formats (CLDF) is purposed to establish guidelines of data and coding format to promote replicability (Forkel et al. 2018). CLDF suggests that (vertically) long table with one value per cell is more interpretable and suitable for computational analysis. As shown in the tables below, Language and Feature could be repeated multiple times; value is assigned to one language per feature. Apart from these three parameters, linguists often add additional columns to indicate sources where they obtain the features and values to ease replication. Language_ID Feature Feature_ID Value Sepa ‚Äúone‚Äù 1 1 Manam ‚Äúone‚Äù 1 1 Kairiru ‚Äúone‚Äù 1 1 Sera ‚Äúone‚Äù 1 2 Sepa ‚Äútwo‚Äù 2 3 Manam ‚Äútwo‚Äù 2 3 Kairiru ‚Äútwo‚Äù 2 4 Sera ‚Äútwo‚Äù 2 5 ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ Language_ID Feature Feature_ID Value Hittite P1-01 1 ? Armenian P1-01 1 1 Greek P1-01 1 1 Albanian P1-01 1 1 Tocharian B P1-01 1 1 Hittite P1-02 2 0 Armenian P1-02 2 0 Greek P1-02 2 0 Albanian P1-02 2 0 Tocharian B P1-02 2 0 ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ 2.3 Databases and resources 2.3.1 Data scarcity No matter what linguistic trait is selected, size always matters. Bayesian phylogenetics is after all a statistical method, which requires a significant amount of data to perform well. Well-curated data is scarce. In their searching for phonological and morphological features, Ringe, Warnow, and Taylor (2002) found that many of them are either poorly curated or poorly understood. Lexical data, on the other hand, is only impressionistically sufficient but rather limited for isolates or languages undergoing substantial phonological and semantic shifts. In their reconstruction of Sahul, Reesink, Singer, and Dunn (2009) notes that lexical characters are simply not available; their reconstruction is thus based on typological traits. 2.3.2 Available resources An increasing number of open-source linguistic databases have been released for both comparative method and computational phylogenetic research. The list below includes databases widely used in research. Lexical data: Indo-European Lexical Cognacy Database: the database is currently not available (accessed May 05, 2022). An earlier version is accessible at this link. Austronesian Basic Vocabulary Database (Greenhill, Blust, and Gray 2008) Contemporary and Historical Resources for the Indigenous Languages of Australia (Chirila) (Bowern 2016) Phonological data: PHOIBLE Morpho-syntactic / Typological data: World Atlas of Language Structure (WALS) AUTOTYP (Bickel et al. 2022) Syntactic Structures of the World‚Äôs Languages Genealogical data: Glottlog (Hammarstr√∂m et al. 2014) Ethnologue (Lewis 2009) References "],["implementation.html", "3 Implementation 3.1 BEASTling 3.2 Phylogeny of Siouan", " 3 Implementation 3.1 BEASTling BEASTling (Maurits et al. 2017) is a suite of command line tools designed to help linguists generate XML files used for phylogenetic analysis. The program itself does not perform the analysis but instead helps linguists prepare the data in a much more friendly way. BEASTling is designed to be linguist-oriented; it takes in data with CSV formats and produces XML files, which are often lengthy and not easily interpretable. Linguists are able to specify model parameters by editing an configuration file in a straightforward and convenient way, without directly dealing with the BEAST interface. One great advantage of BEASTling lies in its integration with Glottolog. This function would require (1) the data is curated following the format described in the previous section; (2) the data contains an iso column specifying the three-letter ISO code for each language, which could be sourced from Glottolog. The addition of an iso column gives the program a prior that all languages contained in the data belong to a single family (Maurits et al. 2017). BEASTling provides an official tutorial of analyzing the phylogeny of Indo-European languages with cognate sets. This tutorial uses typological traits to investigate the phylogeny of Siouan languages. 3.2 Phylogeny of Siouan Siouan is a language family of North America; see the figure below for geograpgical information of selected Siouan languages. Edwin Ko presented a Bayesian phylogenetics analysis of 16 Siouan languages, implemented with BEAST 2 (Ko 2021) (see slides here). Ko (2021) manually coded altogether 258 typological features. Figure 3.1: Map of selected Siouan languages (Ko, 2021). 3.2.1 Pre-processing The CSV file Edwin shared contains 15 languages (without loway-Oto) and a total 248 features (access the file here). The original CSV is a wide table with every column corresponding to one feature and every row one language (see the table below). Language Feature 1 Feature 2 Feature 3 Feature 4 ‚Ä¶ Crow 1 0 0 0 ‚Ä¶ Hidatsa 1 0 0 0 ‚Ä¶ Mandan 1 0 0 0 ‚Ä¶ Lakota 0 0 0 1 ‚Ä¶ Dakota 0 0 0 1 ‚Ä¶ Assiniboine 0 0 0 1 ‚Ä¶ Stoney 0 0 1 0 ‚Ä¶ Chiwere 0 0 0 1 ‚Ä¶ Hochunk 0 0 0 1 ‚Ä¶ Osage 0 0 0 1 ‚Ä¶ Omaha 0 0 0 1 ‚Ä¶ Quapaw 0 0 0 1 ‚Ä¶ Tutelo 0 1 0 0 ‚Ä¶ Biloxi 1 0 0 0 ‚Ä¶ Ofo 0 0 1 0 ‚Ä¶ We first reshape the table and turn it into the expected data format. In the converted table below, we assign each feature an ID (see slide 43 through 48 for a list of features used in the original analysis8). We retrieve ISO code for each language through an R package lingtypology (Moroz 2017), which connects R with Glottolog (V.4.4)(Hammarstr√∂m et al. 2014). The .R file used to do data conversion can be accessed here. Lingtypology retrives data from an earlier version of Glottolog (the latest is v.4.5). ISO codes for Hochunk, Omaha, and Chiwere, which are not avilable in this earlier version, have to be manually added. It should be noted that the header or column names are not arbitrary. For BEAST to identify the language family, the header of ISO and language column must be iso and language respectively. Alternatively, we can also keep the ISO code in a separate file called siouan_code.csv. iso language feature value cro Crow 1 1 hid Hidatsa 1 1 mhq Mandan 1 1 lkt Lakota 1 0 dak Dakota 1 0 asb Assiniboine 1 0 sto Stoney 1 0 iow Chiwere 1 0 win Hochunk 1 0 osa Osage 1 0 oma Omaha 1 0 qua Quapaw 1 0 tta Tutelo 1 0 bll Biloxi 1 1 ofo Ofo 1 0 ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ To proceed, download the data folder directly from the project repository and keep it under the Downloads directory of your computer. The data folder should contain: The original data: typological_siouan-12_12_21.csv The reshaped Siouan data with ISO: siouan_converted_iso.csv The reshaped Siouan data without ISO: siouan_converted.csv ISO code for each language: siouan_code.csv The .R code used to do data conversion: siouan_data.R 3.2.2 Installation 3.2.2.1 Install BEAST 2 with Java As previously mentioned, BEASTling interfaces with BEAST 2 through command lines. BEAST 2 can be installed at its homepage; multiple packages are available for installation, depending on operating systems. BEAST 2 requires Java to run; for the purpose of convenience, please install the BEAST 2 with Java. Figure 3.2: BEAST 2 installation package. If you have downloaded BEAST 2 sucessfully, you should have a folder named BEAST 2.6.X in your Applications folder or any directory you specify. BEAST 2 is a suite of methods and tools. Within the BEAST 2.6.X folder, you should have: LogCombiner TreeAnnotator DensiTree BEAUti AppLaucher You can interact with all of these submodules with their GUIs (Graphical User Interfaces). Alternatively, we can call each module using command lines. In this tutorial, we aim to carry out phylogenetic analysis in command lines completely, without interacting with BEAST 2 directly. 3.2.2.2 Install Beastling First, be sure to install Python! See this blog post to check if Python is installed properly on your operating system. BEASTling is written in Python and can be easily installed via pip, which installs and manages python packages. Pip is a built-in function if Python is downloaded from python.org. # in terminal, check if python and pip are installed python --version python -m pip --version If set up properly, BEASTling can be easily fetched by calling pip install; run the following line to check if BEASTling is successfully installed. # install beastling using pip pip install beastling # check if beastling is installed pip list | grep -F beastling 3.2.2.3 Command line basics Let‚Äôs inspect if data is in its expected format. We first need to set up the working directory, which is Downloads, where you keep the data folder previously downloaded from the project repository. In terminal, we use mkdir to create a directory and cd to navigate directories. The following six command line codes should be sufficient for the purpose of this tutorial. # create a directory mkdir NAME_OF_A_DIRECTORY # go to a directory cd PATH # go to root directory cd . # move up a directory cd .. # switch to a previous directory cd - # list all files in the current directory ls We first go to the data folder; and inspect the first 10 lines of our data using the head command. # go to our data folder; windows uses \\ backslash cd Downloads/data # take a look at the first 10 lines of our data head -10 siouan_converted.csv # your output should look like this: Language_ID,Feature_ID,Value Crow,1,1 Hidatsa,1,1 Mandan,1,1 Lakota,1,0 Dakota,1,0 Assiniboine,1,0 Stoney,1,0 Chiwere,1,0 Hochunk,1,0 3.2.3 Analysis Only one step away from generating the XML file! We need a configuration file to specify parameters we would like to set up so that BEAST 2 can run the analysis based exactly on the configuration. You can use any text-editing program you would like to use to write the config file; be sure to add the .conf extension to the file. Ko (2021)‚Äôs model specification can be divided into three parts: substitution model tree prior clock model We first run the analysis with a substitution model, then move on to a more sophisticated model with a tree prior and a clock model. Figure 3.3: BEAST 2 parameter setup (Ko, 2021). 3.2.3.1 Understand the configuration file A config file is divided into sections, each is labeled with a name enclosed in the square bracket. Some sections require names; some not. Under each section, we may assign a value to each parameter. [section1 (name1)] para1 = value1 para2 = value2 ... [section2 (name2)] para1 = value1 para2 = value2 ... [section3 (name3)] para1 = value1 para2 = value2 ... BEASTling supports parameter specification of 7 different sections. We do not have to specify each parameter for each section. Most of them have default values that we do not want to change. For the purpose of this tutorial, we tweak parameters included in the first five sections. admin section: interface with Glottlog and BEAST 2 MCMC section: MCMC-related model specification languages section: language-related parameters and interface with geneological information from Glottolog model section: model selection clock section: calibrations of the model section geography section: interface with geographical information from Glottolog geo_priors section: calibrations of the geography section 3.2.3.2 Write your configuration file A basic or minimal config file requires a model section only; others could be omitted. In the model section, we at least need to specify which model we would like to use and the path to the data. It should be noted that we must give our model a name. We select models depending on data types. In our case, typological traits are coded in the binary format. BEASTling supports two binary substitution models‚ÄîBinary CTMC9 and Binary Covarion, both of them are widely used in the literature, e.g., Bouckaert et al. (2012), Hoffmann et al. (2021). Ko (2021)‚Äôs analysis also includes these two models (see figure 3.3). The major difference between these two models lies in the transition between states (i.e., absence or presence of a trait). CTMC regulates a fixed rate of transition between states. A language, which might not have a trait (state 0), may evolve to develop this trait (state 1) at some time point, and vice verse. Rate of change is fixed for both directions (Hoffmann et al. 2021). The covarion model, on the other hand, handles rate of change in a dynamic way, allowing variation in the rates of change (Hoffmann et al. 2021), which can either be fast or slow, parameterized by f in the figure below. See J√§ger and Wahle (2021) for an overview of binary models. Figure 3.4: Overview of binary models (Hoffman et al.¬†2021, p.124) (Left: CTMC; Right: Covarion). It is not neccsarily true that covarion is absolutely better than CTMC; subgrouping is affected by other parameters as well. In fact, Ko (2021)‚Äôs analysis shows that CTMC might fit the data better. We can start with a minimal model with CTMC as our model. Lastly, we specify the path to the data. Be sure to add the .conf extension to the file (i.e.¬†siouan_ctmc_basic.conf) and place it under the data folder so that the config file and the data are under the same directory. In addition to model selection, we can specify chainlength in MCMC section. The default is ten million steps or iterations of MCMC, which would normally take at least half an hour to run. In our basic model, we first try 50000 steps. Lastly, we add an admin section, specifying that the output XML file should have the name siouan_ctmc_basic. Be sure to delete commented lines if you want to copy and paste the setting below. # name the output as siouan_ctmc_basic.xml [admin] basename=siouan_ctmc_basic # set the number of iterations to 50000 [MCMC] chainlength = 50000 # select CTMC as our subsitution model; # provide a path to data [model siouan_ctmc_basic] model=binaryctmc data=siouan_converted.csv Now we are all set! Open your terminal and tell BEASTling to compile the XML file, which should be generated within a blink. beastling siouan_ctmc_basic.conf Let‚Äôs call BEAST 2 to analyze the XML file! Make sure your BEAST 2 is properly installed. Check your Applications folder to see if a BEAST 2 folder exists. The folder should have a name BEAST 2.6.X, depending on the version of BEAST you have. The latest version BEAST 2.6.7 should be installed if you follow this tutorial. We call BEAST 2 in command lines by accessing the program contained in the folder10. /Applications/BEAST\\ 2.6.7/bin/beast siouan_ctmc_basic.xml BEAST 2 should be running now! In the output, you will see developers of BEAST 2, summary of the data, citation of the BEAST 2 program, and lastly posterior calculated from each sample. Figure 3.5: Log of posterior caculation. For this basic model, the iteration process lasts within 20 seconds. When completed, two files are generated: siouan_ctmc_basic.log: a log file, keeping prior, likelihood, and posteriors calculated from each sample. siouan_ctmc_basic.nex: a nexus file, containing results of the phylogenetic analysis that has been carried out by BEAST 2. We can have a birds-eye view of subgrouping by calling DensiTree (Bouckaert and Heled 2014), which overlays all trees together to give an overview of subgrouping. You can also select to view the consensus tree, which is a collection of representative trees. The figure below shows the consensus tree and all trees side by side. /Applications/BEAST\\ 2.6.7/bin/DensiTree siouan_ctmc_vanilla.nex Congrats! We just generate our very first set of phylogenetic trees. There are a few mismatches between reported trees and ours. First, Osage and Omaha are grouped together. On closer inspection, you would find subgrouping of the first node is not absolutely conclusive. The node probability (0.419) reported in Ko (2021) is not high (left); the DensiTree shown on the right side is also fuzzy. There are two major differences. First, somehow our model believes Hochunk and Chiwere belong to a different subgroup. Second, Biloxi, which should be a member of the Ohio Valley Siouan, separates its lineage with Totelo and Ofo. Figure 3.6: Phylogenetic trees of Siouan languages (left: consensus tree; right: all trees.). Figure 3.7: Phylogenetic trees of Siouan languages (Ko, 2021). Apart from these basic settings, we could also continue to specify other parameters, not all are suitable for linguistic phylogenetic analysis though. We following Ko (2021)‚Äôs analysis to include a tree prior and a clock model. Among available tree priors, the Yule model and the birth death model are more widely cited in linguistic research; others might be more robust in evolutionary biology (Hoffmann et al. 2021). The major difference between these two models lies in if they assume language extinction. The Yule mode is a pure birth model; which assumes that the dataset contains all the languages in the family and does not allow extinct languages (Hoffmann et al. 2021). The birth-death model, by definition, allows both extinct and extant languages (Hoffmann et al. 2021). The dataset we have does contain extinct languages, most of them spoken in Mississippi Valley, including Ofo, Biloxi, and Tutelo. Some of them are nearly extinct, including Mandan, Osage, and Omaha. Ideally, a birth-death model should better capture the evolution process. In reality, we tend to try both models. Ko (2021)‚Äôs best model indeed includes a birth-death model; the second best uses a Yule model. In addition to specifying tree priors, we can also tweak substitution model‚Äôs (CTMC) rates of change, which could be sampled from a gamma distribution. If a gamma distribution is sliced into four categories11, then we will have four different scaling factors. BEAST 2 would average probabilities calculated by applying each factor12. Furthermore, we include a clock model to estimate the time depth or age of subgrouping (Hoffmann et al. 2021). An evolutionary clock is either strict or relaxed. A strict clock assumes that substitution of states occurs at a fixed rate, which would be an average of all substitutions (Hoffmann et al. 2021). A relaxed clock allows variation in the speed of evolution; some lineage may evolve faster than others (Hoffmann et al. 2021). The speed of change is again sampled from a distribution, which could logarithmic or a gamma distribution. Here, we would set up a relaxed model, with the speed of change sampled from a log distribution, which is the default setting. Lastly, we increase chainlength or iterations to a reasonably sufficient number; a substantial increase would make the whole process tedious. Ko (2021)‚Äôs analysis also includes a 25% burnin, which discards the initial 25% percent of the trees sampled. MCMC typically gets stuck in a low-probability region when searching for an optimal probability; this period of time is considered burnin. Our final config file should look like this: # name the output as siouan_ctmc.xml [admin] basename=siouan_ctmc # increase the iterations to 5000000 steps [MCMC] chainlength = 5000000 # set the tree prior to birth-death model; [languages] tree_prior=birthdeath # select CTMC as our subsitution model; # discard first 25% of iterations; # provide a path to data; # specify rates of change sampled from a gamma distribution [model siouan_ctmc_model] model=binaryctmc log_burnin=25 data=siouan_converted.csv gamma_categories=4 # include a relaxed clock model [clock siouan_ctmc_clock] type=relaxed We then pass our config file to BEASTling to produce the XML file. BEAST 2 reads in the specification in XML file and generates phylogenetic analysis in a nexus file, which is processed by DensiTree for visualization. beastling siouan_ctmc.conf /Applications/BEAST\\ 2.6.7/bin/beast siouan_ctmc.xml /Applications/BEAST\\ 2.6.7/bin/DensiTree siouan_ctmc.nex Figure 3.8: Phylogenetic trees of Siouan languages (left: consensus tree; right: all trees.). It seems that our new model only slightly improves subgrouping while still mistakenly separates Hochunk and Chiwere from the rest of the members, and Biloxi from Mississippi Valley group. The subgrouping of the Mississippi Valley Siouan is not 100% certain in Ko (2021)‚Äôs original analysis, partially because this subgroup has a substantial number of missing data. It should be noted that our data contains 248 out of 258 features used in the original analysis, which might partially accounts for the mismatch here. 3.2.3.3 Play with BEAST 2 and other toolkits In our analysis, ISO code does not really help much since all of our languages belong to the same family; they are monophyletic in nature. If we are dealing with languages from mixed families, specifying which clade some of the languages belong to should be an important prior. Phylogeography, which should be insightful to our analysis, is not working properly in BEASTling. The idea is to make use of the geographical information sourced from Glottolog. BEASTling is able to retrieve latitudes and altitudes from Glottolog (see the following lines, excerpted from the XML file generated by BEASTling) but BEAST 2 raises errors when processing the geographical information. Figure 3.9: Geographical information sourced from Glottolog. You can further tweak parameters included in BEASTling and explore other modules of BEAST 2. Additionally, you can also interact with other toolkit available in the field of Bayesian phylogenetics. For instance, you can use FigTree to view clade probability or NeighborNet (Bryant and Moulton 2004) to inspect if the tree is sufficiently tree-like; some phylogenetic relations resemble more like networks. Have fun! References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
